entity design(clk: clock, rst: bool, ui_in: [bool; 8]) -> uint<8> {
    // The simulated clock runs at 10 KHz, use a counter to turn that into a 1 Hz
    // clock.
    reg(clk) second_counter: uint<32> reset(rst: 0) = if second_counter == 1_000 {
        0
    } else {
        trunc(second_counter + 1)
    };

    // Count the number of ticks on the second clock to build a 1 Hz counter
    reg(clk) val reset(rst: 0) = if second_counter == 0 {
      // If the 0th button is pressed, count down instead of up
        if !ui_in[0] {
            trunc(val + 1)
        } else {
            trunc(val - 1)
        }
    } else {
        val
    };
    val
}


/// This is the top module (main function) of TinyTapeout, before submission,
/// rename it to tt_um_<your username> or something else unique.
/// 
/// You most likely don't want to change this module at all, make any changes
/// you may want to do to `top` instead
#[no_mangle(all)]
entity tt_um_your_design(
    clk: clock,
    rst_n: bool,
    ui_in: [bool; 8],
    uo_out: inv& [bool; 8],
    uio_in: uint<8>,
    uio_out: inv& uint<8>,
    uio_oe: inv& uint<8>,
    ena: bool,
) {
    // Spade uses active high reset, so we'll invert the tt reset
    let rst = !rst_n;
    // If you want to use the bidirectional IO, you'll want to change these
    set uio_out = &0;
    set uio_oe = &0;


    // Put your code to generate the output here
    let output = inst design(clk, rst, ui_in);

    set uo_out = &output.to_bits();
}


/// The playground expects exactly this name for the top module, so we'll wrap
/// the real top module in this
#[no_mangle(all)]
entity top(
    clk: clock,
    rst_n: bool,
    ui_in: [bool; 8],
    uo_out: inv& [bool; 8],
    uio_in: uint<8>,
    uio_out: inv& uint<8>,
    uio_oe: inv& uint<8>,
    ena: bool,
) {
    inst tt_um_your_design$(clk, rst_n, ui_in, uo_out, uio_in, uio_out, uio_oe, ena)
}

